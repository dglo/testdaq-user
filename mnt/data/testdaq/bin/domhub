#!/usr/bin/perl
#
##############################################################################
#                      Icecube System Software
# This software is intended for use on the icecube systems.
# http://www.icecube.wisc.edu/
#
##############################################################################
#
# Coded by Victor Bittorf & Mark Krasberg
# vbittorf@icecube.wisc.edu
# krasberg@icecube.wisc.edu
#
# SVN Manged Source Code
# $LastChangedRevision: 4193 $
# $LastChangedDate: 2009-05-22 11:18:05 -0500 (Fri, 22 May 2009) $
# $HeadURL: http://code.icecube.wisc.edu/daq/sandbox/SystemMonitoring/trunk/domhub.pl $
#
# Last Updated by;
# $LastChangedBy: vbittorf $
my $VERSION = '$LastChangedRevision: 4193 $';
$VERSION =~ s/[^\d]//;


#"Note: this program is in development; functionality is subject change without warning.\n\n";
BEGIN { push (@INC, "$ENV{HOME}/bin/") };

=FIXME

 Fix List:
- giving hubs as a file (fixed as of v3.7)

 Known Errors:
- Cannot take a run config file.

=cut
#
# Recent Changes:
# - Now should sort hubs for quickstatus,
# - Added syntax to stop pages for hubs... (in hubconfig.dat)
#

# domhub.pl
# the basic domhub untility!
#
# This program is used to run commands on DOMHubs
# remotely. The result of the command is returned
# to the user on the remote string-proc.
#
use File::Basename;
use threads;
use threads::shared;
use strict;
use daqm qw(icerr icprob icwarn icpriv icdump parse $HOST SIGINT shortHubName);

#my $VERSION   = 14.12;
our $starttime = time();
use vars qw ($starttime);

$SIG{INT} = $SIG{KILL} = \&SIGINT; 
END { icdump() };
#print "$starttime\n";

#	see (almost) EOF for the sub 'chooseDomhubs' if you
#	want to change the key-words for different DOMHub
#	Lists

# The # of characters allowed per hub...
our $CHARACTERS_PER_HUB = 3;
our $THREAD_JOIN_DELAY  = 4;

# charactesr allowed per label (i.e. crd0 or Hubs: )
our $CHARACTERS_PER_LABEL = 6;
our $HUBS_PER_ROW         = 20;

# The number of hubs to display per table...
our $HUBS_PER_TABLE = ( 75 - $CHARACTERS_PER_LABEL ) / $CHARACTERS_PER_HUB;
our $HOME           = $ENV{HOME};
our $command;
our @domhubs;
our $hubs;
our %Dash_Map            = ();
our $COMP_config         = "$ENV{HOME}/compConfig.dat";
my $excludeFile = "$ENV{HOME}/domhubExclude.txt";
my $failChdskFile = "$ENV{HOME}/domhubFailCount.txt";
my $ChdskFailLevel = 5; # number of fails for checkdisk before excludes
our $MAX_THREAD_RUN_TIME = -1;
my %CheckDiskFails = ();
my %Excludes = ();

# No page flag setup
my @NoPageHubs = ();
my $NO_PAGE_CHAR = ':'; # char to put infront of hub to prevent pages
						# in the hubconfig.dat file.
						# ex. (if = to '~')
						# ~sps-ithub01


#
# Check for exclude clear args
#
if ($ARGV[0] =~ /--clear/i) {
	print "Clearing checkdisk fail count & excludes.\n";
	`rm $excludeFile`;
	# create a new one:
	`touch $excludeFile`;
	# remove the fail count
	`rm $failChdskFile`;
	# make a new one
	`touch $failChdskFile`;
	exit(0);
}
# make ARGV the temp arr (an array w/o -seq, if present)
our @temp_arr = ();

foreach (@ARGV) {
	if (/^\-\w+$/) {
		$Dash_Map{$_} = 1;
		print "Running with `dash command' : $_\n";

		#		return 0;
	}
	else {

		#		return 1;
		push( @temp_arr, $_ );

	}
}
our @commdoms = ();
@ARGV = @temp_arr;



loadExcludes();

if ( defined $ARGV[0] ) { $hubs    = $ARGV[0]; }
if ( defined $ARGV[1] ) { $command = $ARGV[1]; }
else {
	if ( $hubs eq "table" || $hubs eq "status" ) {
		$hubs = "all";
	}
	if ( $commdoms[$hubs] < 10 ) {
		$command = "table";
	}
}

if ( defined $ARGV[2] && !($ARGV[1] eq "distribute" || $ARGV[1] eq "getfile")) {
	print " \n\n";
	print " too many arguments!!!! \n";
	print " \n put command line arguments inside quotes\n";
	print " eg: domhub all \"versions all\"\n\n";
	exit(1);
}

my %Completed_Threads : shared = ();

# map commands to sub references....
my %commandHooks = (
	"checkGPS"          => \&checkGPS,
	"getstffails"       => \&getFails,
	"getcurrent"        => \&getCurrent,
	"getvarlogmessages" => \&getVarLogMsg,
	"getdomcal"         => \&getDomcal,
	"getdomapplctest"         => \&getDomapplctest,
	"getprtcookedcurrents"         => \&getPrtcookedcurrents,
        "getfile"		=> \&getFile,
        "getidom"           => \&getIDOM,
        "postkickstart"	=>	\&postKickstart,
	"getstf"            => \&getSTF,
	"table"             => \&table,
	"status"            => \&table,
	"monitorDomhubApp"  => \&monitorApp,
	"pDown"             => \&pDown,
	"pUp"               => \&pUp,
	"pCycle"            => \&pCycle,
	"ready-iceboot"     => \&readyIceboot,
	"quickstatus"       => \&quickstatus,
	"quicktable"        => \&quickstatus,
	"checkVersions"     => \&checkVersions,
	"distribute"        => \&distribute,
	"checkdisk"         => \&checkdisk,
	"softboot"            => \&softboot,
);

# choose the domhubs to use!
print "DOMHub (v$VERSION)   using command: $command\n";

@domhubs = chooseDomhubs();
@domhubs = sort { ( $a =~ /(\d+)/ )[0] <=> ( $b =~ /(\d+)/ )[0] } @domhubs;
if ( $commandHooks{$command} ) {

	# in this case, we know that the command is in our hash
	#	print "DOMHub (v$VERSION)   using command: $command\n";
	my $ref = $commandHooks{$command};
	&$ref(@domhubs);
}
elsif ( defined($command) ) {

	# we know we have a command,
	# but we don't understand it.
	# print "Threading $command onto @domhubs...\n";
	#	print "DOMHub (v$VERSION)   using command: $command\n";
	print "Threading $command onto @domhubs...\n";
	my %threadMap = dispatchApps2( "$command", @domhubs );
	my @keys      = keys(%threadMap);
	my @infoArr   = joinThreads(%threadMap);
	my $str       = join( "\n", @infoArr );
	print "$str", "\n";
}
exit(0);

# prints the usage for this program.
print "usage:\tdomhub [domhubs] [command]\n\n";
print "version: $VERSION\n";
my @keys = keys %commandHooks;
my $str = join( ", ", @keys );
print "supported commands: $str\n\n";

# # # # # # # # # #
#
#
exit(0);    #
            #

#
# # # # # # # # # #

sub distribute {
	my @domhubs = @_;
	my $destin  = $ARGV[3];
	if ( not $destin ) {
		$destin = "~/";
	}
	my $post_fix = ( $Dash_Map{"-seq"} ? "" : " &" );
	for (@domhubs) {
		no strict;
		system("scp -p $ARGV[2] testdaq\@$_\:$destin $post_fix");
		if ( not $Dash_Map{"-seq"} ) {
			print("copying to $_\n");
		}
	}
}

# does the monitor Domhub App thing...
# Not exactly sure what that does yet - but here it is!
sub monitorApp {
	my @domhubs = @_;
	while (1) {
		my %threadMap   = dispatchApps( "monitorDomhubApp", @domhubs );
		my @infoArr     = joinThreads(%threadMap);
		my @singleLines = ();
		foreach my $block (@infoArr) {
			@singleLines = ( @singleLines, split( "\n", $block ) );
		}
		monitorHACK(@singleLines);
		sleep(1);
	}
}

# takes a map of threads and joins the threads, returning
# each thread result in an array...
# the order of the array is based on the order that
# the keys() function returns the keys for the hash
sub joinThreads {
	my %threadMap = @_;
	my $len       = keys %threadMap;
	my @returnArr = ();
	my %detached = ();
	print "Waiting for $len DOMHubs to finish...\n";
	# try really hard to sort the hubs!
	my @mapKeys = sorthubs(keys(%threadMap));
	my %reverseMap = ();
	foreach (@mapKeys) {
		if (not defined $threadMap{$_}) {
		#print ">>> [INTERNAL ERROR] Lost a thread for $_ ... where did it go??\n";
		open( EMAIL, "|mail -s \"not defined \$threadMap{\$_}\" krasberg\@icecube.wisc.edu" )
	  			|| die "Cannot open mail: $!";
		print EMAIL "$_ => $threadMap{$_}\n" foreach keys %threadMap;
		close EMAIL;
		#print ">>> [INTERNAL ERROR] The thread for $_ is undefined. IGNORING HOST $_\n";
		delete $threadMap{$_};
		} else {
			$reverseMap{ $threadMap{$_}->tid() } = $_;
		}
	}
	my $killed_threads = 0;
	#        my $endtime = time();
	#        my $duration = $endtime - $starttime;
	foreach my $key ( sorthubs(keys %threadMap) ) {
		my $thr   = $threadMap{$key};
		my $done  = 0;
		my $count = 0;
		while ( not $done ) {
			$count++;
			my @threads_to_join = ();
			{
				lock %Completed_Threads;
				$done = $Completed_Threads{ $thr->tid() };
			}
			if ( not $done ) {
				my @arr = grep { not $Completed_Threads{ $_->tid() } } threads->list();
				my $num = $#arr + 1;

				if ($#arr < 6) {
					my $waiting_str = join ", ", map { $reverseMap{ $_->tid() } if defined $_ } @arr[0 .. $#arr];
					print "Waiting on $num DOMHUBs... [ $waiting_str ]\n";
				} else {
					print "Waiting on $num DOMHUBs... \n";
				}
			}
			if ( $count % 5 eq 0 ) {
				my $endtime  = time();
				my $duration = $endtime - $starttime;
				print
"$key is taking a long time...              ($duration seconds so far)\n";
				if ( $MAX_THREAD_RUN_TIME ne -1 && $duration > $MAX_THREAD_RUN_TIME ) {
					print
"\n--- Max Run Time Reached --- Killing All Threads ---\n\n";
					my @kids = getkids($$);
					print "killing child processes.\n";
					foreach (@kids) {
						my $id = $_;
						my $n = kill 2, $_;
						if ($n) {
							print "### killed child (pid=$id)\n";
						} else {
							print "### failed to kill child (pid=$id)\n";
						}
					}
#					foreach (threads->list()) {
#						if ( !$Completed_Threads{ $_->tid() } ) {
#							#print "### Killing $reverseMap{ $_->tid() } \n";
#							my $hub = $reverseMap{ $_->tid() };
#							$Completed_Threads{ $_->tid() } = 1;
#							$detached{$_->tid()} = 1;
#							$_->detach();
#							$killed_threads++;
#						}
#					}
				}
			}
			sleep $THREAD_JOIN_DELAY unless $done;
		}
		my $stuff = "";
		$stuff = $thr->join() unless $detached{$thr->tid()};
		# check to see if at least got a number or letter back
		if ( not $stuff =~ /[\d\w]/ ) {
			#icerr ("Hub did not respond: $key.");
            # Don't page for non-response; Nagios does this
            icprob ("Hub did not respond: $key.");
			if ($command =~ /checkdisk/i) {
				$CheckDiskFails{$key}++;
				icwarn("Recording checkdisk fail for $key; now at $CheckDiskFails{$key} fails.");
			}
		}
		else {
			# Check for No-Page Flag
			# (prevent pages for certin HUBs, specificed in hubconfig.dat)
			if (grep { $key =~ /$_/i } @NoPageHubs) {
				# replace >>> w/ :::
				$stuff =~ s/^>>>/::: [no-page] /mg;
			}
			
			push( @returnArr, $stuff );
		}
	}
#	push (@warnings, ">>> $killed_threads hubs did not finish in allowed time.") if $killed_threads > 0;
	my $endtime  = time();
	my $duration = $endtime - $starttime;
	print
"All DOMHubs have finished.                      (took $duration seconds)\n\n\n";
	return @returnArr;
}

# a simple function that takes a command line
# and threads the command, and returns the thread.
# if the thread is joined, the thread returns
# what ever the command returns.
sub threadCommand {
	# ARGUMENTS: <command> [flag]
	# the flag is 1 if the result of the command is not important,
	# the only thing that matters is if the command was run.
	my ( $commandLine, $flag ) = @_;
	my $sub;    # the sub to thread.

        select(undef, undef, undef, 0.005);
        
	if ( $Dash_Map{"-seq"} ) {
		print "Running in sequence mode...\n";

	   # we need to run in sequence mode. (so we don't actually thread anything)
		print "::[domhub] Execute: `$commandLine' ... ";

		# store the result of the command
		my $txt = `$commandLine`;
		print "done\n";    # print done!
		print $txt;        # print the result of the command.
		$sub = sub {
			{    # the sub just returns the result of the command run above,
				    # this is to make it fit the format for the other subs
				lock %Completed_Threads;

				# add this thread ID to the completed thread hashmap.
				$Completed_Threads{ threads->self()->tid() } = 1;
			}
			return $txt;
		  }
	}
	else {

		# else, we thread!
		$sub = sub {

			# get the command to run
			my $cmd = shift;
			my $toReturn;
			if ( $flag && $flag ne 2 ) {

			# if we are flagged, we run the command and have it print, then just
			# return "done"
				system($cmd);
				print "Done with `$cmd'\n";
				$toReturn = "Done with `$cmd'\n";
			}
			else {

				# run the command, capture the result
				$toReturn = `$cmd`;
			}
			{
				# we're done with the command, so we add this thread to the
				# completed thread map.
				lock %Completed_Threads;

				# add this thread ID to the completed thread hashmap.
				$Completed_Threads{ threads->self()->tid() } = 1;
			}

		   # return! (this is what will be returned with $thr->join() is called)
		   # the thread will wait here until it is joined.
			return $toReturn;
		};
	}

	# start the thread!
	my $thr = threads->new( $sub, $commandLine );
	threads->yield();
	die ">>> &threadCommand FAILURE to create new thread; UNKOWN error." unless defined $thr;
	# the command is now executing, however our program continues.
	# return the thread we just made.
	return $thr;
}

# takes a command and a lsit of domhubs,
# then threads the command onto each domhub.
# returns a hash in the form of:
# 	{ DOMHUB => THREAD OBJECT}
sub dispatchApps {

	# command and domhub list
	my ( $cmd, @domhubs ) = @_;

	# new empty map
	# ( DOMHUB => THREAD OBJECT )
	my %threadMap = ();

	# for every domhub...
	foreach my $domhub (@domhubs) {

		# start a thread with the command (ssh'd)
		my $thr;
		if ( $cmd =~ /checkdisk/ ) {
			$thr = threadCommand("ssh -xT $domhub $cmd $domhub 2>/dev/null");
		}
		else {
			$thr = threadCommand("ssh -xT $domhub $cmd 2>/dev/null");
		}

		# add the thread to the local thread map,
		$threadMap{$domhub} = $thr;
	}

	# return the thread map
	return %threadMap;
}

# takes a command and a lsit of domhubs,
# then threads the command onto each domhub.
# returns a hash in the form of:
# 	{ DOMHUB => THREAD }
# There is one key difference between this
# one and the other dispatch apps....
# this one will allow the commands to print
# to the terminal where the one one will collect
# the command's out put. This one should only be
# used if you don't care about the output
# from the commands and you want the user to see that output.
sub dispatchApps2 {
	my ( $cmd, @domhubs ) = @_;
	my $args = "-T";
	my %threadMap = ();
        if (index($cmd, "sudo") != -1) {
            $args = "-t";
        }
	foreach my $domhub (@domhubs) {
		my $thr = threadCommand( "ssh $args $domhub $cmd 2>/dev/null", 1 );
		$threadMap{$domhub} = $thr;
	}
	return %threadMap;
}

# Does the `get current' thing...
sub getDomcal {
	my @domhubs = @_;
	system("mkdir -p /mnt/data/testdaq/domcal/");

	#	system("rm -rf /tmp/current/current.*");
	foreach my $domhub (@domhubs) {
		print "getting domcal files for $domhub \n";

		#     system("rm /tmp/domhub-status/domhub-status-result.$domhub.txt");
               system("mkdir -p /mnt/data/testdaq/domcal/$domhub/");
        
		system(
"scp -p testdaq\@$domhub:~/domcal/domcal* /mnt/data/testdaq/domcal/$domhub/"
		);
		system("mkdir -p /mnt/data/testdaq/domcal/$domhub/histos.$domhub");
		system(
"scp -p testdaq\@$domhub:~/domcal/histos/* /mnt/data/testdaq/domcal/$domhub/histos.$domhub/"
		);

#     system("cat /tmp/domhub-status/domhub-status-result.$domhub.txt >> /tmp/domhub-status/domhub-status-all.txt");
		print "\n";
	}
}
# Does the `get current' thing...


sub getSTF {
	my @domhubs = @_;

	#	system("rm -rf /tmp/current/current.*");
	foreach my $domhub (@domhubs) {
		system("mkdir -p /mnt/data/testdaq/stf/$domhub/");
		print "getting stf files for $domhub \n";

		#     system("rm /tmp/domhub-status/domhub-status-result.$domhub.txt");
		system(
"scp -p testdaq\@$domhub:~/Results/STF/* /mnt/data/testdaq/stf/$domhub/"
		);
		system(
			"scp -p testdaq\@$domhub:~/stf_*.txt /mnt/data/testdaq/stf/$domhub/"
		);

#     system("cat /tmp/domhub-status/domhub-status-result.$domhub.txt >> /tmp/domhub-status/domhub-status-all.txt");
		print "\n";
	}
}

# gets Fails...
# not sure what fails are - but it gets them!
# Does the `get current' thing...
sub getCurrent {
	my @domhubs = @_;
	system("mkdir -p /mnt/data/testdaq/Results/Current/");

	#	system("rm -rf /tmp/current/current.*");
	foreach my $domhub (@domhubs) {
		system("mkdir -p /mnt/data/testdaq/Results/Current/current.$domhub/");
		print "getting current files for $domhub \n";
		system(
"scp -p testdaq\@$domhub:~/Results/Current/* /mnt/data/testdaq/Results/Current/current.$domhub/"
		);

#        system("zip current.$domhub.zip current.$domhub/*", $commdoms[$hubs] );
		if ( $commdoms[$hubs] < 10 ) { }
		print "\n";
	}
}

sub getDomapplctest {
	my @domhubs = @_;
	system("mkdir -p /mnt/data/testdaq/Results/Domapplctest/");

	#	system("rm -rf /tmp/current/current.*");
	foreach my $domhub (@domhubs) {
		system("mkdir -p /mnt/data/testdaq/Results/Domapplctest/domapplctest.$domhub/");
		print "getting domapplctest files for $domhub \n";
		system(
"scp -p testdaq\@$domhub:~/Results/domapp-lc-test/* /mnt/data/testdaq/Results/Domapplctest/domapplctest.$domhub/"
		);

#        system("zip current.$domhub.zip current.$domhub/*", $commdoms[$hubs] );
		if ( $commdoms[$hubs] < 10 ) { }
		print "\n";
	}
}

sub getPrtcookedcurrents {
	my @domhubs = @_;
	system("mkdir -p /mnt/data/testdaq/Results/Prtcookedcurrents/");

	#	system("rm -rf /tmp/current/current.*");
	foreach my $domhub (@domhubs) {
		system("mkdir -p /mnt/data/testdaq/Results/Prtcookedcurrents/prtcookedcurrents.$domhub/");
		print "getting prtcookecurrent files for $domhub \n";
		system(
"scp -p testdaq\@$domhub:~/Results/prtCookedCurrents/* /mnt/data/testdaq/Results/Prtcookedcurrents/prtcookedcurrents.$domhub/"
		);

#        system("zip current.$domhub.zip current.$domhub/*", $commdoms[$hubs] );
		if ( $commdoms[$hubs] < 10 ) { }
		print "\n";
	}
}
sub getFile {
	my @domhubs = @_;
	my $filename = $ARGV[2];
    my ($filebase, undef) = fileparse($filename);
	system("mkdir -p /mnt/data/testdaq/getfile");
	foreach my $domhub (@domhubs) {
		system("mkdir -p /mnt/data/testdaq/getfile/$domhub/");
		print "getting $filename from $domhub \n";		
		system(
                "scp -p testdaq\@$domhub:$filename /mnt/data/testdaq/getfile/$domhub/$filebase"
		);
	}
}
sub getIDOM {
	my @domhubs = @_;
	system("mkdir -p /mnt/data/testdaq/Results/iDOM");

	#	system("rm -rf /tmp/current/current.*");
	foreach my $domhub (@domhubs) {
		system("mkdir -p /mnt/data/testdaq/Results/iDOM/iDOM.$domhub/");
		print "getting monitoring files for $domhub \n";
		system(
"scp -p testdaq\@$domhub:~/Results/iDOM/iDOM.dat /mnt/data/testdaq/Results/iDOM/iDOM.$domhub/"
		);
#	system("mkdir -p /mnt/data/testdaq/monitoring");
#
#	#	system("rm -rf /tmp/current/current.*");
#	foreach my $domhub (@domhubs) {
#		system("mkdir -p /mnt/data/testdaq/monitoring/monitoring.$domhub/");
#		print "getting monitoring files for $domhub \n";
#		system(
#"scp -p testdaq\@$domhub:monitoring.090418.zip /mnt/data/testdaq/monitoring/monitoring.$domhub/monitoring.090418.$domhub.zip"
#		);
#
#        system("zip current.$domhub.zip current.$domhub/*", $commdoms[$hubs] );
	}
}

sub postKickstart {
	my @domhubs = @_;
#	system("mkdir -p /mnt/data/testdaq/monitoring");

	#	system("rm -rf /tmp/current/current.*");
	foreach my $domhub (@domhubs) {
		system("scp -p /mnt/data/testdaq/kickstart.zip $domhub:");
		print "performing post-kickstart on $domhub, remember to pUp first \n";
		system("ssh testdaq\@$domhub unzip -oq kickstart.zip");
		system("ssh testdaq\@$domhub post-kickstart");
                system("ssh testdaq\@$domhub makequickstatus");
                
#        system("zip current.$domhub.zip current.$domhub/*", $commdoms[$hubs] );
	}
}

# gets Fails...
# not sure what fails are - but it gets them!
sub getFails {
	my @domhubs = @_;
	system("mkdir -p /tmp/stffails/");
	system("rm -rf /tmp/stffails/stffails.*");
	foreach my $domhub (@domhubs) {
		system("mkdir -p /tmp/stffails/stffails.$domhub/");
		print "getting STFfails files for $domhub \n";
		system(
"scp -p testdaq\@$domhub:stf_fail.txt* /tmp/stffails/stf_fail.$domhub.txt"
		);
		system(
"scp -p testdaq\@$domhub:stf_results.txt* /tmp/stffails/stf_results.$domhub.txt"
		);
		print "\n";
	}
}

# This is the messy task of processing the monitor information
# and collecting it into table form.
# Arguments: A list of strings, where the strings are from running monitordomhubap
# on a domhub.
sub monitorHACK {
	my @page = @_;
	my @hub;
	my $thubs = 0;
	my $hubs  = 0;

	# get the base lines ready & labeled
	my $line1 = "HUBs                                    = ";
	my $line2 = "Waiting for RMI method calls            = ";
	my $line3 = "Getting drivers                         = ";
	my $line4 = "SOFTbooting                             = ";
	my $line5 = "Discovery phase                         = ";
	my $line6 = "DOMStatusList - waiting for other hubs  = ";
	my $line7 = "reserveDOM - hub should be taking data  = ";
	my $line8 = "TruncatedRead                           = ";
	my $line0 = "java DOMHubApp                          = ";
	my @domhubappstatus;
	my $truncateflag;
	my ( $WRM, $GDR, $SOF, $DIS, $DSL, $RDO, $TRN ) =
	  ( 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 );
	my $JAVA_DOMHUB_APP = 1;
	my $junk            = "";

	foreach (@page) {

		# for each long string...
		my $line = $_;
		chop $line;

		my $truncateflag = 0;

		# if we have /SUMMARY/ ...
		if (/SUMMARY/) {

			# we have a domhub
			$hubs = $hubs + 1;

			# get the hub number
			( $hub[$hubs] ) = split( " domhubApp", $line );
			( my $junk, $hub[$hubs] ) = split( "HUB", $hub[$hubs] );

			# if its AMANDA thent here is no hub #, so use AM
			if    (/AMANDA/) { $hub[$hubs] = "AM" }
			if    (/WCZAR2/) { $hub[$hubs] = "W2" }
			elsif (/WCZAR/)  { $hub[$hubs] = "W1" }
			if    (/SCUBE/)  { $hub[$hubs] = "SC" }

			# add the hub # to the first line.
			$line1 = $line1 . " $hub[$hubs]";
			$thubs = $thubs + 1;

			if ( $WRM < 1 ) { $line2 = $line2 . "  0"; }
			if ( $GDR < 1 ) { $line3 = $line3 . "  0"; }
			if ( $SOF < 1 ) { $line4 = $line4 . "  0"; }
			if ( $DIS < 1 ) { $line5 = $line5 . "  0"; }
			if ( $DSL < 1 ) { $line6 = $line6 . "   "; }
			if ( $RDO < 1 ) { $line7 = $line7 . "  0"; }
			if ( $TRN < 1 ) { $line8 = $line8 . "  0"; }

			$WRM             = 0;
			$GDR             = 0;
			$SOF             = 0;
			$DIS             = 0;
			$DSL             = 0;
			$RDO             = 0;
			$TRN             = 0;
			$JAVA_DOMHUB_APP = 0;
		}
		if (/software:\s*?(\d+)\s*domhubapps/) {

			# if there is software, add it to line zero (the last line).
			$line0           = $line0 . "  $1";
			$JAVA_DOMHUB_APP = 1;
		}
		if (/Waiting/) {

			# if its waiting, add that to line 2
			( my $junk, $domhubappstatus[$hubs] ) = split( "=", $line );

			$line2 = $line2 . " $domhubappstatus[$hubs]";
			$WRM   = 1;
		}

		if (/drivers/) {

			# if it has drivers, add that to line 3
			( my $junk, $domhubappstatus[$hubs] ) = split( "=", $line );

			$line3 = $line3 . " $domhubappstatus[$hubs]";
			$GDR   = 1;
		}

		if (/Softboot/) {

			# if its in softboot, add that to line 4
			( my $junk, $domhubappstatus[$hubs] ) = split( "=", $line );

			$line4 = $line4 . " $domhubappstatus[$hubs]";
			$SOF   = 1;
		}

		if (/Discovery/) {

			# if has Discovery add that to line 5
			( my $junk, $domhubappstatus[$hubs] ) = split( "=", $line );

			$line5 = $line5 . " $domhubappstatus[$hubs]";
			$DIS   = 1;
		}

		if (/DOMStatus/) {

			# if we have DOMStatus, add that to line 6
			( my $junk, $domhubappstatus[$hubs] ) = split( "=", $line );
			if ( int( $domhubappstatus[$hubs] ) ) {
				$line6 = $line6 . "  *";
				$DSL   = 1;
			}
		}

		if (/reserve/) {

			# if it has reserve, add that to line 7
			( my $junk, $domhubappstatus[$hubs] ) = split( "=", $line );

			$line7 = $line7 . " $domhubappstatus[$hubs]";
			$RDO   = 1;
		}

		if (/Oh/) {

			# if 0h appears in the line, then add that to line 8
			( my $junk, $domhubappstatus[$hubs] ) = split( "=", $line );

			$line8        = $line8 . " $domhubappstatus[$hubs]";
			&TRN          = 1;
			$truncateflag = 1;
		}

	}

	# Check our flags..
	if ( $WRM < 1 )             { $line2 = $line2 . "  0"; }
	if ( $GDR < 1 )             { $line3 = $line3 . "  0"; }
	if ( $SOF < 1 )             { $line4 = $line4 . "  0"; }
	if ( $DIS < 1 )             { $line5 = $line5 . "  0"; }
	if ( $DSL < 1 )             { $line6 = $line6 . "   "; }
	if ( $RDO < 1 )             { $line7 = $line7 . "  0"; }
	if ( $TRN < 1 )             { $line8 = $line8 . "  0"; }
	if ( $JAVA_DOMHUB_APP < 1 ) { $line0 = $line0 . "  0"; }
	printHoriz();

	# pring out the table.
	print "SUMMARY\n";
	print "$line1\n";
	print "$line0\n";
	print "$line2\n";
	print "$line3\n";
	print "$line4\n";
	print "$line5\n";
	print "$line6\n";
	print "$line7\n";

	# if we have truncate flag, print out an additional line.
	if ( $truncateflag == 1 ) {
		print "$line8\n";
	}
	printHoriz();
	print "waiting to restart momentarily... (hit ^C to stop the program) \n";
	sleep 5;

	# sleep... this method will be re-called from another method.

	#
	# END MONITOR DOMHUB APP
	#

}

# # # # # # # # # # # # # # #
#							#
#							#
#			TABLE			#
#							#
#							#
# # # # # # # # # # # # # # #

# this is very messay..
sub table {
	$MAX_THREAD_RUN_TIME = 120;
	my @domhubs   = @_;
	my %threadMap = dispatchApps( "status short", @domhubs );
	my @infoArr   = joinThreads(%threadMap);

	# we have @infoArr now... but in order
	# to make it work with the old table code,
	# which reads a file, we have to break
	# @infoArr into an arary of lines...
	# to make it look like it came from a file.
	my @page = ();
	foreach (@infoArr) {
		my @arr = split( "\n", $_ );
		@page = ( @page, @arr );
	}
	printTableTable(@page);
}

# Prints the Table command's table.
sub printTableTable {

# expects a list of strings, each string is the result of running status on a domhub.
	my @page = @_;
	my $hubs = 0;

	# a list for each line, the colmuns will all be from the same hub.
	my @hub_line  = ();
	my @comm_line = ();
	my @conf_line = ();
	my @iceb_line = ();
	my @busy_line = ();
	my @stf_line  = ();
	my $thubs     = 0;
	my $tcomm     = 0;
	my $tconf     = 0;
	my $ticeb     = 0;
	my $tbusy     = 0;
	my $tstf      = 0;

	# temp variables.
	my @hub;
	my $hub_number;
	my @commdoms;
	my @busydoms;
	my @stfservdoms;
	my @icebootdoms;
	my @configbootdoms;

	my $linewarning = "";
	my $junk        = "";

	# # # # # # # # # # #
	#
	# # # # # # # # # # #
	#
	# BIG FOR LOOP!!!

	foreach (@page) {
		my $line = $_;
		parse $line;
		if (/SUMMARY/) {
			$hubs++;
			my ($full_hub_name) = split( " SUMMARY", $line );
			my $short = shortHubName($full_hub_name);
#			my ( $junk, $hub_number ) = split( "HUB", $full_hub_name );
#			if    (/AMANDA/) { $hub_number = "AM" }
#			if    (/WCZAR2/) { $hub[$hubs] = "W2" }
#			elsif (/WCZAR/)  { $hub[$hubs] = "W1" }
#			if    (/SCUBE/)  { $hub_number = "SC" }
			push( @hub_line, "$short" );
			$hub[$hubs] = $full_hub_name;
			$thubs = $thubs + 1;
		}
		elsif (/communicating (\d+) DOMs/) {
			( $junk, $commdoms[$hubs] ) = split( "communicating ", $line );
			( $commdoms[$hubs], $junk ) = split( " DOMs", $commdoms[$hubs] );
			if ( $commdoms[$hubs] < 10 ) {
				$commdoms[$hubs] = " " . $commdoms[$hubs];
			}
			push( @comm_line, "$commdoms[$hubs]" );
			$tcomm = $tcomm + $commdoms[$hubs];

			if (/configboot/) {
				( $junk, $configbootdoms[$hubs] ) =
				  split( "configboot ", $line );
				( $configbootdoms[$hubs], $junk ) =
				  split( " DOMs", $configbootdoms[$hubs] );
				if ( $configbootdoms[$hubs] < 10 ) {
					$configbootdoms[$hubs] = " " . $configbootdoms[$hubs];
				}
				push( @conf_line, "$configbootdoms[$hubs]" );
				$tconf = $tconf + $configbootdoms[$hubs];
			}
			else {
				push( @conf_line, "  " );
			}
			if (/iceboot/) {
				( $junk, $icebootdoms[$hubs] ) = split( "iceboot ", $line );
				( $icebootdoms[$hubs], $junk ) =
				  split( " DOMs", $icebootdoms[$hubs] );
				if ( $icebootdoms[$hubs] < 10 ) {
					$icebootdoms[$hubs] = " " . $icebootdoms[$hubs];
				}
				push( @iceb_line, "$icebootdoms[$hubs]" );
				$ticeb = $ticeb + $icebootdoms[$hubs];
			}
			else {
				push( @iceb_line, "  " );
			}
			if (/busy/) {
				( $junk, $busydoms[$hubs] ) = split( "busy ", $line );
				( $busydoms[$hubs], $junk ) =
				  split( " DOMs", $busydoms[$hubs] );
				if ( $busydoms[$hubs] < 10 ) {
					$busydoms[$hubs] = " " . $busydoms[$hubs];
				}
				push( @busy_line, "$busydoms[$hubs]" );
				$tbusy = $tbusy + $busydoms[$hubs];
			}
			else {
				push( @busy_line, "  " );
			}
			if (/stfserv/) {
				( $junk, $stfservdoms[$hubs] ) = split( "stfserv ", $line );
				( $stfservdoms[$hubs], $junk ) =
				  split( " DOMs", $stfservdoms[$hubs] );
				if ( $stfservdoms[$hubs] < 10 ) {
					$stfservdoms[$hubs] = " " . $stfservdoms[$hubs];
				}
				push( @stf_line, "$stfservdoms[$hubs]" );
				$tstf = $tstf + $stfservdoms[$hubs];
			}
			else {
				push( @stf_line, "  " );
			}
		}

	}    # # # # # # # #
	     #      END FORLOOP
	     # # # # # # # #

	my @lbls = ( "HUB:  ", "COMM: ", "CONF: ", "ICEB: ", "BUSY: ", "STF:  " );
	print "SUMMARY\n";
	displayTable(
		\@lbls,
		(
			\@hub_line,  \@comm_line, \@conf_line,
			\@iceb_line, \@busy_line, \@stf_line,
		)
	);
	print
"HUBS= $thubs; COMM= $tcomm; CONF= $tconf; ICEB= $ticeb; BUSY= $tbusy; STF= $tstf\n";
	if ( ( $tbusy > 1 ) && ( $tbusy < 100 ) && ( $ticeb > 500 ) ) {
		print "\n";
		icerr
		  "Number of busy DOMs and number of Iceboot DOMs is strange!\n";
		icerr
		  "Number of busy DOMs and number of Iceboot DOMs is strange!\n";
		icerr
		  "Number of busy DOMs and number of Iceboot DOMs is strange!\n";
		icerr
"(it is not possible to say there is a definite problem though) \n";

		#           print "\n";
	}
}

sub getSubRow {
	my ( $arr_ref, $init, $end ) = @_;
	my @arr = @$arr_ref;
	return @arr[ $init .. $end ];
}

# confirm
# ask the user to confirm checkGPS.
# let them know there may be iterruptions to other people.
sub confirm {
	print "\n\n\t\tCheck GPS\nChecking GPS may conflict with processes\n";
	print "currently running on the DOMs.\n";
	print "Do you with to continue? (yes/no) ";
	my $answer = <STDIN>;
	if ( $answer =~ /yes/ ) {
		print "Check GPS: confirmed.\n";
	}
	else {
		print "Check GPS exiting.\n";
		exit(0);
	}
}

=getCardList @domhubs
 slightly miss-named.
 takes an arr of domhubs (i.e. strings like sps-ithub01)
 and returns an array of threads (one for each domhub)
 which are currently processing a checkGPS on a domhub
 the list of threads is returned in an order such that:
 the first thread is doing a checkGPS for the first domhub
 in the argument list for this sub.
 The threads, if joined, will return REFERENCE to a list of strings,
 where the list is that status of all the cards (idecating
 missing cards with a " ") and the first of the list is
 the domhub name (in full: ex. sps-ithub01)
=cut

sub getCardList {
	my @domhubs    = @_;
	my @hubColumns = ();

	# foreach domhub...
	foreach my $domhub (@domhubs) {

		# make a new Thread!!!!
		my $thread = threads->new(
			sub {
				my $dh     = shift;
				my $warned = "";

				# call checkGPS with args 'noconf' and 'nodisp'
				my $stuff = `ssh $dh checkGPS noconf nodisp`;
				parse $stuff;
				my ( $stats, @warnings ) = split( "\n", $stuff );

				# split the results into a list
				my @cardsStats = split( "-", $stats );
				@cardsStats = ( $warned, $dh, @cardsStats );
				return \@cardsStats;
			},
			$domhub    # domhub is the argument for the `anon' sub we just made.
		);
		push( @hubColumns, $thread );
	}
	return (@hubColumns);
}

=checkGPS DOMHub
takes a list of DOMHubs (ex. sps-ithub01 ...) and reports
to the terminal the status of all the cards on all the given
domhubs. This processes is threaded.
Note: this sub will request a confirmation form the user.
=cut

sub checkGPS {
	my @domhubs = @_;
	confirm();                             # ask the user to confirm.
	print "Getting card listings...\n";    # Let them know what we're doing.
	    # get a list of threads working on the DOMHubs
	my @thrColumns = getCardList(@domhubs);

	# announe that we're joining the threads!
	print "Joining threads... please wait... \n";
	my @hubColumns = ();    # <<<< this is our array of arrays of strings.
	foreach my $thr (@thrColumns) {

		# For each thraed...
		my $id = $thr->tid();        # get ID
		my ($ref) = $thr->join();    # Join the thread; store result in $ref
		     # since $ref is a reference to an Array of strings;
		my ( $warning, @hubCol ) = @$ref;
		parse $warning;
		push( @hubColumns, \@hubCol );
	}

	# generate the report for the user.
	printKey();
	my $cur_tbl = 0;
	my $tbl     = 0;    # the current table we're on.
	while ( $cur_tbl * $HUBS_PER_ROW <= $#hubColumns ) {
		my $init     = $cur_tbl * $HUBS_PER_ROW;
		my $end      = ( $cur_tbl + 1 ) * $HUBS_PER_ROW - 1;
		my @subTable = @hubColumns[ $init .. $end ];
		generateReport(@subTable);
		$cur_tbl++;
	}
	
}

=printKey
 prints the key to the table...
 does nothing else...
=cut

sub printKey {

# big format thing!!! Go perl!
# basic overview of `format' (just incase)
# format's are built on 2 line pairs: a picture and a text.
# the @ just means text... a | means 'center', and < means pad left, and > means right
# the list of strings is put into the picture....
	format STDOUT =
@|||||||
" "
@|||||||
" "
@||||||||||||||||||||||||||||||||||||||||||||||
"Check GPS report"
@<<<<<<<<<<<
"Key codes:"
@>>>>>>>    @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
".", "External & GPS; all looks good"
@>>>>>>>    @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
"BAD", "External & No GPS"
@>>>>>>>    @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
"INT", "Internal & GPS"
@>>>>>>>    @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
"DOR", "Internal & No GPS"
@>>>>>>>    @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
"\" \"", "No DOR card detected"
@>>>>>>>    @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
"dt", "Delta-time not 2,000,000"
@>>>>>>>    @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
"*?*", "Unknown card type (clksel file?)"
@>>>>>>>    @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
"#?", 	   "Unexpect directory structure on hub"
@|||||||
" "
.
	write;
}

# generateReport
# this just takes a 2D data structure and makes a table
# and outputs it for the user.
# very messy.
sub generateReport {
	my @domhubs = @_;

	#print2d(@domhubs);
	my $report =
	    "format STDOUT =\n"
	  . "@|||\n\" \"\n"
	  . "@<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n"
	  . "\"-----------------------------------------------\"\n";
	my ( $pic, $nums ) = formatRow( getRow( 0, @domhubs ) );

	$report =
	    $report . "@"
	  . ( "<" x ( $CHARACTERS_PER_LABEL - 1 ) )
	  . $pic . "\n"
	  . "\"Hubs:\", "
	  . $nums . "\n";
	for ( 1 .. 8 ) {
		my ( $pic, $nums ) = formatRow( getRow( $_, @domhubs ) );
		$report =
		    $report . "@"
		  . ( "<" x ( $CHARACTERS_PER_LABEL - 1 ) )
		  . $pic . "\n" . "\"crd"
		  . ( $_ - 1 ) . "\", "
		  . $nums . "\n";
	}
	$report = $report
	  . "@<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n"
	  . "\"-----------------------------------------------\"\n" . ".";
	eval($report);
	write;
}

=getRow index (ARRAYREF ARRAYREF ARRAYREF ...)
takes a 2D data structure (an array of columns) and
returns 1 row of that arary, the row is the given index.
any element in the row that fits /hub(\d\d)/ or /-(..)/
will be condenced to the ( ) part.
=cut

sub getRow {
	my ( $i, @arr ) = @_;
	my @retrn = ();
	foreach (@arr) {
		my $temp = $_->[$i];
		if ( $temp =~ /hub(\d{2})/ || $temp =~ /-(..)/ ) {
			$temp = $1;
		}
		push( @retrn, $temp );
	}
	return @retrn;
}

=formatRow
takes a row of data, and returns an array of the form:
 ( "@|| @|| @|| ...",
 	"$_[0], $_[1], $_[2] ..." )
note that all elements in the array that is given are double quoted
prior to processing. See doubleString.
=cut

sub formatRow {
	my @rowData = doubleString(@_);
	my $pic     =
	  ( "@" . ( "|" x ( $CHARACTERS_PER_HUB - 1 ) ) ) x ( $#rowData + 1 );
	my $dat = join( ", ", @rowData );
	return $pic, $dat;
}

=doubleString (String String ...)
 takes an array of strings, returns
 those strings in the same order
 except they're double quoted,
 ex. "Hello World" => ""Hello World""
=cut

sub doubleString {
	my @arr       = @_;
	my @returnArr = ();
	foreach (@arr) {
		push( @returnArr, "\"$_\"" );
	}
	return @returnArr;
}

# chooses the DOMHubs and returns them.
# the choice is based on what the global variable
# $hubs is equal to...
sub chooseDomhubs {
	my @domhubs = ();
	if ( $hubs =~ /\.xml/ ) {
		print "Using config xml for domhubs...\n";
		my $page = `cat $hubs`;
		my @lines = split( "\n", $page );
		foreach (@lines) {
			print "Line=$_\n";
			if (/\s*\<domConfigList\>(spt?s6?4?)-(\d+)i/) {
				my $hub = "$1-ichub$2";
				push( @domhubs, $hub );
			}
			elsif (/\s*\<domConfigList\>(spt?s6?4?)-(\d+)t/) {
				my $hub = "$1-ithub$2";
				push( @domhubs, $hub );
			}
			elsif (/\s*\<domConfigList\>(spt?s6?4?)-amanda/) {
				my $hub = "$1-amanda";
				push( @domhubs, $hub );
			}
			elsif (/\s*\<domConfigList\>sps-icetop/) {
				push( @domhubs, "sps-ithub01" );
				push( @domhubs, "sps-ithub02" );
				push( @domhubs, "sps-ithub03" );
				push( @domhubs, "sps-ithub04" );
			}
			elsif (/\s*\<domConfigList\>(.+?\-.+?)\-/) {
				push( @domhubs, $1 );
			}
		}
		print "Domhubs from config: " . join( ", ", @domhubs ), "\n";
	}
	elsif ( $hubs =~ /\./ ) {
		print "Using $hubs file for domhubs...\n";
		my $page = `cat $hubs`;
		my @lines = split( "\n", $page );
		foreach (@lines) {
			my @parts = split( "[\,\;\:]", $_ );
			foreach (@parts) {
				# "maintenance mode"
				# Eclude every DOM that has a '#' before it.
				next if (/^\s*\#/);
				if (/^\s*([\w\d]+\-?[\w\d]+)/) {
					push( @domhubs, $_ );
				}
			}
		}
		print "found domhubs: @domhubs\n";
	}
	elsif ( $hubs =~ /([\,\;\:])/ ) {
		@domhubs = split( "$1", $hubs );
	}
	else {
		my $cat = `cat ~/domhubConfig.dat`;
		if ( $cat =~ /"$hubs"(.*?)"/s ) { #capture to next quote... this is bad!!
			print "Using entry for $hubs in ~/domhubConfig.dat.\n";
			@domhubs = split( " ", $1 ); # this will have every domhub word.
			my @good_hubs = (); # hubs that are not excluded, will be poplated in the loop.
			foreach (@domhubs) {
				if (/^$NO_PAGE_CHAR.+$/) {
					s/.//;
					push (@NoPageHubs, $_);
					print "Found no-page flag for $_\n";
				}
				if (/^\s*\#/) {
					print "Excluding domhub: $_\n";
				} else
				{
					push (@good_hubs, $_);
				}
			}
			# replace @domhubs w/ good_hubs to effectively remove hubs excluded in the loop above
			@domhubs = @good_hubs;
			
			if (@NoPageHubs) {
				my $cnt = @NoPageHubs;
				icprob("There are < $cnt > machine(s) in the no-page category");
			}
			# Warn about no-page hubs
			print( "Using hubs: " . join( ", ", @domhubs ) . "\n" );
		}
		else {
			@domhubs = $hubs;
		}
	}
	# remove domhub that should be excldued and report error!
	my @ok_domhubs = ();
	foreach (@domhubs) {
		if (defined $Excludes{$_}) {
			icprob("Exluding $_ from this run. (It appears in $excludeFile)");
		} else {
			push (@ok_domhubs, $_);
		}
	}
	return @ok_domhubs;
}

=printHoriz 
	print a horizontal line, i.e.
	--------------------------------------------------
=cut

sub printHoriz {
	print "-" x 66, "\n";
}

=pDown
	Runs the command pDown on the given DOMHubs.
	Also calls parseInfo to extract meaningful info
	from the power down.
=cut

sub pDown {
	my @domhubs = @_;
	print "Powering DOWN DOMHubs...\n";
	my $str = join( ", ", @domhubs );
	print "DOMHubs: $str\n";
	my %threadMap = dispatchApps( "pDown", @domhubs );
	my @keys      = keys(%threadMap);
	my @infoArr   = joinThreads(%threadMap);
	parseInfo(@infoArr);
	print "DOMHubs powered DOWN.\n\n";
	
}

=pUp
	Runs the command pUp on the given DOMHubs.
	Also calls parseInfo to extract meaningful info
	from the power up.
=cut

sub pUp {
	my @domhubs = @_;
	print "Powering UP DOMHubs...\n";
	my $str = join( ", ", @domhubs );
	print "DOMHubs: $str\n";
	my %threadMap = dispatchApps( "pUp", @domhubs );
	my @keys      = keys(%threadMap);
	my @infoArr   = joinThreads(%threadMap);
	parseInfo(@infoArr);
	print "DOMHubs powered UP.\n\n";
	
}

=pCycle
	Runs the command pCycle on the given DOMHubs.
	Also calls parseInfo to extract meaningful info
	from the power cycle.
=cut

sub pCycle {
	my @domhubs = @_;
	print "Power Cycling DOMHubs...\n";
	my $str = join( ", ", @domhubs );
	print "DOMHubs: $str\n";
	my %threadMap = dispatchApps( "pCycle", @domhubs );
	my @keys      = keys(%threadMap);
	my @infoArr   = joinThreads(%threadMap);
	parseInfo(@infoArr);
	print "DOMHubs power-cycled.\n\n";
	
}

=softboot
	Runs the command "softboot all" on the given DOMHubs.
=cut

sub softboot {
	my @domhubs = @_;
	print "Softbooting DOMHubs...\n";
	my $str = join( ", ", @domhubs );
	print "DOMHubs: $str\n";
	my %threadMap = dispatchApps( "softboot all", @domhubs );
	my @keys      = keys(%threadMap);
	my @infoArr   = joinThreads(%threadMap);
#	parseInfo(@infoArr);
	print "DOMHubs softbooted, use status to check DOMs are in iceboot.\n\n";
}

sub checkVersions {
	print "\n\ncheckVersions softboots DOMs and may conflict\n";
	print "with already running processes.\n";
	print "Do you wish to continue? (yes/no) ";
	my $answer = <STDIN>;
	if ( $answer =~ /yes/ ) {
		print "checkVersions: confirmed.\n\n";
	}
	else {
		print "checkVersions exiting.\n\n";
		exit(0);
	}

	my @domhubs = @_;
	print "Checking mainboard build versions...\n";
	my $str = join( ", ", @domhubs );
	print "DOMHubs: $str\n";
	my %threadMap = dispatchApps( "checkVersions all", @domhubs );
	my @keys      = keys(%threadMap);
	my @infoArr   = joinThreads(%threadMap);
	parseInfo(@infoArr);
	
}

=parseInfo
	Takes an array of strings and sorts through it
	to find line warnings and build versions. This
	is only for use in pUp, pDown, and pCycle.
	Line warnings are anything that start with >>> after a new line.
=cut

sub parseInfo {
	my @infoArr   = @_;
	my %build_map = ();
	my @hubs      = ();
	my @turned_on = ();
	my @moved_ib  = ();
	foreach (@infoArr) {

		#            print $_;
		my @lines = split( "\n", $_ );
		parse($_) foreach @lines;
		my @line = grep { /hub:/ } @lines;
		$line[0] =~ /hub: (\S+)/;
		my $name = $1;
		push( @hubs, $name );
		foreach (@lines) {
			if (/Moved (\d+) DOMs into iceboot build version ([\d\w]+)/) {
				if ( defined( $build_map{$2} ) ) {
					my $ref = $build_map{$2};
					if ( defined( $ref->{$name} ) ) {
						$ref->{$name} = $ref->{$name} + 1;
					}
					else {
						$ref->{$name} = $1;
					}
				}
				else {
					$build_map{$2} = { $name => $1 };
				}
			}
			if (/There are (\d+) DOMs in iceboot/) {
				my $str = $1;
				if ( $str < 10 ) {
					$str = " " . $str;
				}
				push( @moved_ib, $str );
			}
		}
	}
	print "\n";
	my @hubNums = ();
	foreach (@hubs) {
		push( @hubNums, shortHubName($_) );
		#                print "hub = *$_*\n";
#		if (/hub(.+)/) {
#			push( @hubNums, $1 );
#		}
#		if (/dmice/i) {
#			push( @hubNums, "DM" );
#		}
#		elsif (/AMANDA/i) {
#			push( @hubNums, "AM" );
#		}
#		elsif (/WCZAR2/i) {
#			push( @hubNums, "W2" );
#		}
#		elsif (/WCZAR/i) {
#			push( @hubNums, "W1" );
#		}
#		elsif (/SCUBE/i) {
#			push( @hubNums, "SC" );
#		}
#		else {
#			push( @hubNums, "UN" );
#		}
	}
	displayTable( [ "HUB:  ", "ICEB: " ], ( \@hubNums, \@moved_ib ) );
	my $hubstr = join( " ", @hubNums );
	my @builds = keys(%build_map);
	my $format =
	    "format STDOUT =\n"
	  . "@<<<<<<<<< @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n"
	  . "\"HUB\", \"$hubstr\"\n";
	$format = $format . "-" x 66;
	$format = $format . "\n";
	foreach (@builds) {
		my $mapref = $build_map{$_};
		my @nums   = ();
		foreach (@hubs) {
			if ( defined( $mapref->{$_} ) ) {
				my $num = $mapref->{$_};
				if ( $num < 10 ) {
					push( @nums, " $num" );
				}
				else {
					push( @nums, "$num" );
				}
			}
			else {
				push( @nums, "  " );
			}
		}
		my $str = join( " ", @nums );
		$format = $format
		  . "@<<<<<<<<< @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n"
		  . "\"$_\", \"$str\"\n";
	}
	my $totalsum = 0;
	foreach (@builds) {
		my $map_ref = $build_map{$_};
		my $sum     = 0;
		foreach ( keys(%$map_ref) ) {
			$sum += $$map_ref{$_};
		}
		printf( "There are %4s DOMs that have build%6s.\n", $sum, $_ );
		$totalsum = $totalsum + $sum;
	}
	print "\n";
	$format = $format . ".";
	if ( $#builds > 0 ) {
		icerr "Not all $totalsum DOMs have the same iceboot build version.";
		eval($format);
		write;
	}
}

#
# Displays a table; arguments are as follows:
# Label_Array_Ref Row_Array_Ref Row_Array_Ref ...
#
#
sub displayTable {
	my $labels  = shift @_;
	my @rows    = @_;
	my $cur_tbl = 0;
	while ( $cur_tbl * $HUBS_PER_ROW <= $#{ $rows[0] } ) {
		printHoriz();
		my $init = $cur_tbl * $HUBS_PER_ROW;
		my $end  = ( $cur_tbl + 1 ) * $HUBS_PER_ROW - 1;
		my $num  = 0;
		foreach (@$labels) {
			print "$_"
			  . join( " ", getSubRow( $rows[$num], $init, $end ) ) . "\n";
			$num++;
		}
		printHoriz();
		$cur_tbl++;
	}
}

sub readyIceboot {
	my @domhubs   = @_;
	my %threadMap = dispatchApps( "ready-iceboot", @domhubs );
	my @values    = keys %threadMap;
	foreach (@values) {
		$threadMap{$_}->detach();
		print "$_ => ready-iceboot\n";
	}
	sleep 5;
	print "DOMHubs are `ready-iceboot'\n";
	
}

#
# This was put together quickly -- sorry
# Its not very well mashed together....
# The idea of this sub is to have something like
# domhub all table
# execpt its domhub all quicktable (status vs quickstatus)
# this method combines the joining of the threads and the processing,
# in order to make it run faster. Normally this would be seperated into 2 methods,
# but for now its one.
sub quickstatus {
	$THREAD_JOIN_DELAY   = 1;
	$MAX_THREAD_RUN_TIME = 60;
	my @domhubs = sort {$a cmp $b} @_;    # the domhub list
	                     # thread map, (DOMHUB => THREAD OBJECT)
	                     #     ex. ("SPS-ITHUB01" => $thr)
	my %threadMap = dispatchApps( "quickstatus", @domhubs );
	my $len       = keys %threadMap;
	my @page      = joinThreads(%threadMap);

	# Check for hubs that we might have caught transitioning through configboot
	my $configboot = 0;
	foreach (@page) {
	    if (/Unexpected DOM.*000000000000/) {
		$configboot = 1;
		last;
	    }
	}
	# Just rerun the whole darn thing
	if ($configboot) {
	    print "Found DOMs in configboot.  Will try again momentarily...\n";
	    sleep 15;
	    %threadMap = dispatchApps( "quickstatus", @domhubs );
	    @page = joinThreads(%threadMap);
	}

	my $hubs = 0;
	my $line1     = "HUB:  ";
	my $line2     = "COMM: ";
	my @hub_line  = ();
	my @comm_line = ();
	my $thubs     = 0;
	my $tcomm     = 0;
	my $hub_number;
	my @commdoms;

	my $junk = "";

	foreach (@page) {
		my $line = $_;
		if (/(.+) SUMMARY/) {
			$hubs++;
			my $hub = $1;
			push( @hub_line, shortHubName($hub) );
#			($junk,$hub) = split("HUB",$hub);
#			if    (/AMANDA/) { $hub = "AM" }
#			if    (/WCZAR2/) { $hub = "W2" }
#			elsif (/WCZAR/)  { $hub = "W1" }
#			if    (/SCUBE/)  { $hub = "SC" }
#			push( @hub_line, "$hub" );
			$thubs++;
		}
		if (/communicating (\d+) DOMs/) {
			push( @comm_line, "$1" );
			$tcomm = $tcomm + int($1);
		}
		parse $_;
	}
	print "SUMMARY\n";
	my $cur_tbl = 0;
	while ( $cur_tbl * $HUBS_PER_ROW <= $#hub_line ) {
		my $init = $cur_tbl * $HUBS_PER_ROW;
		my $end  = ( $cur_tbl + 1 ) * $HUBS_PER_ROW - 1;
		printHoriz();
		printf "HUB:  " . " %2s" x $HUBS_PER_ROW . "\n", @hub_line[ $init .. $end ];
		printf "COMM: " . " %2s" x $HUBS_PER_ROW . "\n", @comm_line[ $init .. $end ];
		printHoriz();
		$cur_tbl++;
	}
	print "\n";
	print "HUBS= $thubs; COMM= $tcomm\n";
	
}

sub checkdisk {
	$THREAD_JOIN_DELAY   = 1;
	$MAX_THREAD_RUN_TIME = 120;
	loadCheckdiskFails();
	my @domhubs   = @_;
	my $total     = 0;
	my %threadMap = dispatchApps( "checkdisk", @domhubs );
	my @keys      = keys(%threadMap);
	my @infoArr   = joinThreads(%threadMap);
	my $ok        = 1;
	my $hosts     = 0;
	my @errs = ();
	my $disks_checked;
	foreach (@infoArr) {
		my $txt = $_;
		$hosts++;

		#		print $txt if ($txt =~ /\w+/);
		if ($txt =~ /Checked (\d) Disks/i) {
			$disks_checked = $disks_checked + $1;
		}
		parse $txt;
	}
	print "Checked $disks_checked disks.\n";
	saveCheckdiskFails();
	saveExcludes();
}

# Loads names listed in checkdisk filure file
# the numbers are icremented every time checkdisk does not return properly.
# the format of the file should be each line has:
# NUMBER HUBNAME
sub loadCheckdiskFails {
	if (not -e $failChdskFile) {
		icwarn("Making a new Checkdisk Failure count file (none currently exists): $failChdskFile");
		`touch $failChdskFile`;
		%CheckDiskFails = ();
	} else {
		open (FAILS, "$failChdskFile") || die "Cannot open $failChdskFile: $!\n";
		while (<FAILS>) {
			if (/^(\d+)\s+(\S+)/) {
				$CheckDiskFails{$2} = $1; # add hub => number
			}
		}
		close FAILS;
	}
}
# saves the contents of %CheckDiskFails to $failChdskFile
# in teh correct format to be read by loadCheckdiskFails
sub saveCheckdiskFails {
	if (not -e $failChdskFile) {
		print "Making $failChdskFile\n";
		`touch $failChdskFile`;
	}
	open (FAILS, ">$failChdskFile") || die "Failed to write to $failChdskFile: $!\n";	
	for (keys %CheckDiskFails) {
		my $hub = $_;
		printf FAILS "%d %s\n", $CheckDiskFails{$hub}, $hub;
	}
	close FAILS;
}

# loads hubs that should be excluded from the $excludeFile
# the hubs are loaded into %Excludes
sub loadExcludes {
	if (not -e $excludeFile) {
		icwarn ("Making new Exclude file (there is none right now): $excludeFile");
		`touch $excludeFile`;
	} else {
		open (XCLUDE, "$excludeFile") || die "Cannot open $excludeFile: $!\n";
		while (<XCLUDE>) {
			chomp;
			$Excludes{$_} = 1;
		}
		close XCLUDE;
	}
}

# saves the contents of %Excludes to $excludeFile,
# in the correct format for $excludeFile
# also automatically adds things that need to be excldued.
sub saveExcludes {
	foreach (keys %CheckDiskFails) {
		my $hub = $_;
		if ($CheckDiskFails{$hub} >= $ChdskFailLevel) {
			if (not defined $Excludes{$hub}) {
				icprob ("Adding $hub to exclude file, it has failed checkdisk $CheckDiskFails{$hub} times.");
				$Excludes{$hub} = 1;
			}
		}
	}
	open (XCLUDE, ">$excludeFile") || die "Cannot write to $excludeFile: $!\n";
	foreach (keys %Excludes) {
		if ($Excludes{$_}) {
			print XCLUDE "$_\n";
		}
	}
	close XCLUDE;
}

sub getkids {
	my $ppid = shift;
	my $ps = `ps --ppid $ppid`;
	my @kids = ();
	foreach (split /\n/, $ps) {
		if (/^\s*(\d+)/) {
			push (@kids, $1);
		}
	}
	my @kidskid = ();
	foreach (@kids) {
		push (@kidskid, getkids($_));
	}
	return @kidskid, @kids;
}

# sorts hub names -- I don't know why other sorting methods
# are not working... This is strange!!
# takes a list of hub names & returns sorted, I hope!
sub sorthubs {
	my @list = @_;
	# complex sorting algorithm?
	my @sorted = sort {
		$a cmp $b;
	} @list;
	return @sorted;
}
