#!/usr/bin/perl
#
# Coded by Victor Bittorf
#
# Use strict to enforce good habbits!
#
our $VERSION = 2.21;
BEGIN { push( @INC, "$ENV{HOME}/bin/" ) }
use strict;
$SIG{INT} = $SIG{KILL} =
  sub { warn "$0 : Caught Signal; exiting.\n"; exit(1); };
use daqm qw(
  parse getMessages $HOST
  icerr icwarn icpriv icdump email strip
  $VERBOSE loadconfig
  @Errors @Warnings @Problems @Private ARGVGrep
  $DAQM_PATH %DASH_HASH $HOSTNAME
);

#
# monitor.pl
#
# Monitors a program and emails if any errors occur.
#
ARGVGrep( \@ARGV );

#mark.krasberg@icecube.wisc.edu
our ( $PROGRAM, $TARGETS, $ARGS ) = @ARGV;
our $CONFIG_FILE = "$DAQM_PATH/monitor.config";
our $EMAIL_FREQ  = 20;
our $REPORT;
our $_new         = 0;
our %STATE        = ();
our %CONFIG       = ();
our %STRIP_STATE  = ();
our $RUNTIME      = localtime;
our $short_cmd    = $1 if $PROGRAM =~ /([^\/]+)$/;
#our $PAGER_FILE   = "$ENV{HOME}/monitor.$ARGS.page";
our $PAGER_FILE   = "/tmp/page";
our @config_names = qw(
  email-freq page emails priv-emails
  valid_cmds email-freq
);

my $CLEAR_DOMHUB_FLAG = 1;

#my $md5sum = $1 if `echo "$TARGETS" | md5sum` =~ /^(\S+)/;
#$STATE_FILE = "$ENV{HOME}/.$HOST.$short_cmd.monitor.$md5sum";

`mkdir $DAQM_PATH/monitor` unless -e "$DAQM_PATH/monitor";
my $STATE_FILE = "$DAQM_PATH/monitor/monitor.$ARGS.$HOST";


# Check for clear command...
if (defined $DASH_HASH{'--clear'}) {
	print "Clearing monitor system...\n";
	if (not -e $STATE_FILE) {
		print "\n*** FAILED ***\n\n";
		print "Failed to clear monitor!\n";
		print "State file does not exist for:\n";
		print "$STATE_FILE\n";
		print "Do you have the right args?\n";
		print "(You have to give enough information so I know what file to clear...)\n";
		print "ex: 'monitor --clear domhub ic40 checkdisk'\n";
		print "ex: 'monitor --clear domhub sps quickstatus'\n";
		exit(0);
	} else {
		print "State file contents are:\n";
		system("cat $STATE_FILE");
		system("rm $STATE_FILE");
		system("touch $STATE_FILE");
		print "\n";
		print "-" x 65;
		print "\n CLEARED\n";
		exit(0);
		system("rm $STATE_FILE");
		system("echo \"\" > $STATE_FILE");
		exit(0);
	}
}

if ( -e $CONFIG_FILE ) {
	my $txt = `cat $CONFIG_FILE`;
	%CONFIG = loadconfig( $txt, @config_names );
	my @valid_cmds = split( /,/, $CONFIG{'valid_cmds'} );
	my $ok = grep { /^$ARGS$/ } @valid_cmds;
	die "$ARGS is NOT a valid program to monitor! (valid cmds = @valid_cmds)"
	  unless $ok;
}
else {
	warn "$0: No config file found; expected a config file $CONFIG_FILE.\n";
}
$EMAIL_FREQ = $CONFIG{'email-freq'};
my @EMAILS = split m|,| , $CONFIG{'emails'};


# $STATE_FILE = "$ENV{HOME}/.$HOST.$short_cmd.$ARGV[1]_monitor";

readStateFile();

# Fill the DAQM arrays with the errors...
geterrors();
our $errs2    = \@Errors;
our $probs    = \@Problems;
our $warns    = \@Warnings;
our $privs    = \@Private;
our %CUR_ERRS = ();

foreach (@$warns) {
	my $err  = $_;
	my $prob = $_;
	my $full = $_;
	$err  =~ s/~~~/>>>/;
	$prob =~ s/~~~/>>>/;
	my $serr  = strip($err);
	my $sprob = strip($prob);
	if ( defined $STATE{$serr} || defined $STATE{$sprob} ) {
		my $temp = defined $STATE{$serr} ? $serr : $sprob;
		print
"Schmitt trigger Found... $temp existed as an error before, and now it is a warning...\n"
		  if $VERBOSE;
		if (defined $STATE{$serr}) {
			push (@$errs2, $err);
		} else {
			push (@$probs, $prob);
		}
		next;
	}
}
# combine the problems and errors into $err
my @temp_arr = ( @$errs2, @$probs );
my $errs = \@temp_arr;
foreach (@$errs) {
	my $temp = $_;
	my $s    = strip $_;
	my $warn = $s;

	# check for schmitt trigger stuff
	$_new = 1 if ( not defined $STATE{$s} );
	$STRIP_STATE{$s} = $temp;
	$STRIP_STATE{$temp} = $temp;
	$CUR_ERRS{$s}    = 1;
	$STATE{$s}       = defined $STATE{$s} ? $STATE{$s} + 1 : 1;
}


my @fixed = grep { not $CUR_ERRS{$_} } keys %STATE;
foreach (@fixed) {
	print "Deleting $_ from \$STATE.... (its in fixed).\n" if $VERBOSE;
	delete $STATE{$_};
}
`chmod +w $STATE_FILE -f`;
open( OUT, ">$STATE_FILE" )
  || die "$0 : cannot open state file $STATE_FILE; $!\n";
printf OUT ( "<%d> %s\n", $STATE{$_}, $STRIP_STATE{$_} ) foreach keys %STATE;
close OUT;
`chmod -w $STATE_FILE`;


my $newpage = (grep { />>>/ } @fixed) || @$errs2;

my $counter = getMaxNum();
my $e       = stringAllErrs();
my $fixed   = @fixed;
my $Eprobs  = keys %CUR_ERRS;

my $pagefile;

if ($VERBOSE) {
	print " -- STATE FILE --\n";
	printf "<%d> %s\n", $STATE{$_}, $STRIP_STATE{$_} foreach keys %STATE;
	print "\n\nCurrent Errors:\n";
	print $e;
	print
	  "\n\n\$_new = $_new\n\$counter = $counter\nCurrent problems=$Eprobs\n";
	if ($_new) {
		print "*** Will email new problems...\n";
	}
	elsif ($Eprobs) {
		printf "*** Will email in %d runs... (0 means this run.)\n",
		  ( $EMAIL_FREQ - $counter % ( $EMAIL_FREQ + 1 ) );
	}
	elsif ( $fixed && not $Eprobs ) {
		print "*** Will email all clear\n";
	}
	else {
		print "*** No email.\n";
	}
}

if ( $DASH_HASH{'-p'} && $newpage ) {
	my $time = localtime;
	open( PAGER, ">$PAGER_FILE" ) || die "Cannot open $PAGER_FILE file; $!";

	print PAGER "# Monitor Paging file for: $PROGRAM $ARGS\n";
	print PAGER "\n# *** AUTO-GENERATED FILE ***\n";
	print PAGER "# Do not delete this file; it will be recreated if you do.\n";
	print PAGER "# This file will be deleted by the montior.pl script\n";
	print PAGER "# after all the problems are gone.\n";
	print PAGER "\n#  --- THIS LIST MAY BE OUT OF DATE! --- \n";
	print PAGER "# ( Generated < $time > )";
	print PAGER
	  "\n# The follow are the errors found at the creation of this file;\n";
	print PAGER
	  "# You can run `$PROGRAM $TARGETS $ARGS' to see these errors.\n\n";
	print PAGER
"# ----------------------------------------------------------------- \n\n";
	my @keys = @$errs2;
	@keys = sort {
		if ($STATE{$a} ne $STATE{$b}) {
		$STATE{$a} <=> $STATE{$b};
		} else {
			$a cmp $b;
		}} @keys;
	
	foreach (@keys) {
		if ($VERBOSE) {
			print "write to page file: $_\n";
			print " ( $STRIP_STATE{$_} )\n";
		}
		print PAGER $STRIP_STATE{$_}, "\n";
	}
	close PAGER;
}

my $REPORT_STRING = sprintf "%s %43s
monitor v%f
Error Summary
%s

REPORT:
> $PROGRAM $TARGETS $ARGS
- - - - - - - - - - - - - - - - - - - - - - - - -
$REPORT
- - - - - - - - - - - - - - - - - - - - - - - - -
", "command", "$PROGRAM $TARGETS $ARGS", $VERSION, $e;
if ($_new) {
	print "EMAILING NEW!\n$REPORT_STRING\n" if $VERBOSE;
	email( " new errors      ", $REPORT_STRING, \@EMAILS );
}
elsif ( $fixed > 0 && not $Eprobs ) {
	print "EMAILING FIXED!\n$REPORT_STRING\n" if $VERBOSE;
	my $cleared = join "\n", map { $STRIP_STATE{$_} } @fixed;
	email( " all clear       ", $REPORT_STRING, \@EMAILS );
}
elsif ( $fixed > 0 ) {
	print "EMAILING Some Fixed!\n$REPORT_STRING\n" if $VERBOSE;
	email( " improvement     ", $REPORT_STRING, \@EMAILS );
}
elsif ( $Eprobs > 0 && $counter % $EMAIL_FREQ == 1 ) {
	print "EMAILING OLD!\n$REPORT_STRING\n" if $VERBOSE;
	email( " old errors      ", $REPORT_STRING, \@EMAILS );
}

if ( not @$errs2 && -e "$PAGER_FILE" ) {
	if ( $DASH_HASH{'-p'} ) {
		`rm -f $PAGER_FILE`;
	}
}

if (@$privs) {
	email(
		" private warnings ",
		"
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@ NOTE: The processes on the remote hosts are still running @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


The processes on $HOSTNAME have been killed.

(you can use domhub to kill these remote processes)
ex. as $ENV{USER}\@$HOSTNAME :
'domhub $TARGETS \"killall df\"'
    - or try -
'domhub $TARGETS \"killall $ARGS\"'

(to date, DF is the most common cause of this problem;
however different processes may need to be killed as well.)

" . join( "\n", @$privs ) . "\n\n$REPORT",
		[ split( /,/, $CONFIG{'priv-emails'} ) ]
	);
}

sub geterrors {
	$REPORT = `$PROGRAM $TARGETS $ARGS`;
	if ($REPORT =~ /no problems found/im) {
		`domhub --clear-fails`;
	}
	my @lines = split( /\n/, $REPORT );
	parse($REPORT);
}

sub getMaxNum {
	my $max = 0;
	foreach ( keys %STATE ) {
		$max = $STATE{$_} if ( $STATE{$_} > $max );
	}
	return $max;
}

sub stringerr {
	my $err      = shift;
	my $err_full = $STRIP_STATE{$err};
	my $num      = $STATE{$err};
	my $str      = sprintf( "[E%4d] %s", $num, $err_full );
	return $str;
}

sub stringAllErrs {
	my @keys = keys %STATE;
	@keys = sort { 
		if ($STATE{$a} ne $STATE{$b}) {
		$STATE{$a} <=> $STATE{$b};
		} else {
			$a cmp $b;
		}} @keys;
	return join( "\n",
		( map { stringerr($_) } @keys ),
		( map { "[FIXED] $STRIP_STATE{$_}" } @fixed ),
		( map { "[ warn] $_" } @$warns ),
		( map { "[ priv] $_" } @$privs ) )
	  . "\n";
}

sub readStateFile {
	# check if state file exists
if ( -e $STATE_FILE ) {

	# read in the state
	open( IN, $STATE_FILE )
	  || die "$0 : cannot open state file $STATE_FILE\n";
	while (<IN>) {
		print "(state file) $_\n" if $VERBOSE;
		if (/^<(\d+)>\s+(.+)/) {
			$STRIP_STATE{$2} = $1;
		}
	}
	close IN;
	foreach ( keys %STRIP_STATE ) {
		my $full = $_;
		my $s    = strip $_;
		$STATE{$s} = $STRIP_STATE{$full};
		print "\$STATE{'$s'} => $STRIP_STATE{$full}\n" if $VERBOSE;
		$STRIP_STATE{$s}    = $full;
		$STRIP_STATE{$full} = $full;
	}
}
}
